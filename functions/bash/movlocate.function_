function movlocate (){
    local CPU_USAGE=default  # default (include hyper threadding..etc) / real
    local MAIN_DIR="/tmp/movlocate"
    local STOCK_DIR="$HOME/.cache/movlocate"

    if   [[ ! -d "${STOCK_DIR}" ]] && [[ ! -d "${MAIN_DIR}" ]] ;then
        doas mkdir -p "${STOCK_DIR}"
        doas chmod 644 "${STOCK_DIR}"
        mkdir -p "${MAIN_DIR}"
        movlocate -v
        echo "Ready."
    elif [[   -d "${STOCK_DIR}" ]] && [[ ! -d "${MAIN_DIR}" ]] ;then
             cp -pr "${STOCK_DIR}" -T "${MAIN_DIR}"
    elif [[ ! -d "${STOCK_DIR}" ]] && [[   -d "${MAIN_DIR}" ]] ;then
        doas cp -pr "${MAIN_DIR}"  -T "${STOCK_DIR}"
    else
        [[ "$(ls -1A "${MAIN_DIR}" |grep -c .TMP)" -ne 0 ]] &&
        /usr/bin/rm "${MAIN_DIR}"/*.TMP
    fi

    if [[ "$(ls -1A "${MAIN_DIR}" |grep -c .TMP)" -ne 0 ]] ;then
        /usr/bin/rm "${MAIN_DIR}"/*.TMP
    fi

    case "$1" in
        -h|--help)
            "${MAIN_DIR}"/tlocate --help |
            sed -e 's|tlocate|movlocate|g' |
            less -
            return 100    ;;
        -c|--check)
            if ( sha512sum -c "${MAIN_DIR}"/updatedb.sha512 &>/dev/null ) ;then
                echo "Up to date."
            else
                echo "Old data, update."
            fi
            return 200    ;;
        -u|--update)
            locate -beir \\.mp4$ >"${MAIN_DIR}/mp4.TMP" &
            locate -beir \\.mkv$ >"${MAIN_DIR}/mkv.TMP" &
            locate -beir \\.avi$ >"${MAIN_DIR}/avi.TMP" &
            locate -beir \\.wmv$ >"${MAIN_DIR}/wmv.TMP" &
            locate -beir \\.flv$ >"${MAIN_DIR}/flv.TMP" &
            locate -beir \\.iso$ >"${MAIN_DIR}/iso.TMP" &
            locate -beir \\.m4v$ >"${MAIN_DIR}/m4v.TMP" &
            wait
            ;;
        -v|--verbose)
            locate -beir \\.mp4$ |tee "${MAIN_DIR}/mp4.TMP" &
            locate -beir \\.mkv$ |tee "${MAIN_DIR}/mkv.TMP" &
            locate -beir \\.avi$ |tee "${MAIN_DIR}/avi.TMP" &
            locate -beir \\.wmv$ |tee "${MAIN_DIR}/wmv.TMP" &
            locate -beir \\.flv$ |tee "${MAIN_DIR}/flv.TMP" &
            locate -beir \\.iso$ |tee "${MAIN_DIR}/iso.TMP" &
            locate -beir \\.m4v$ |tee "${MAIN_DIR}/m4v.TMP" &
            wait
            ;;
        *)
            SORT_BY_BASENAME=true
            if [[ "${SORT_BY_BASENAME}" = "true" ]] ;then
                echo "${MAIN_DIR}"/movlocate-data*.txt |
                \
                xargs -P0 -I{} "${MAIN_DIR}"/tlocate -t {} \
                      --no-dirs --files-nonzero	--has-read --no-links $* |
                \
                sed -e "s|^${MAIN_DIR}\/movlocate-data.*\.txt:||g" |
                while read i ;do
                    echo "$(basename "$i")v@_@v${i}"
                done |sort -f |sed -e 's|^.*v@_@v||g'
            else
                echo "${MAIN_DIR}"/movlocate-data*.txt |
                \
                xargs -P0 -I{} "${MAIN_DIR}"/tlocate -t {} \
                      --no-dirs --files-nonzero	--has-read --no-links $* |
                \
                sed -e "s|^${MAIN_DIR}\/movlocate-data.*\.txt:||g" |
                sort -f
            fi
            return 0
            ;;
    esac

    case "${CPU_USAGE}" in
        default)
            local CPU="$(getconf _NPROCESSORS_ONLN)"
            ;;
        real)
            local CPU="$(grep ^cpu\\scores /proc/cpuinfo |uniq |awk '{print $4}')"
            ;;
    esac
    cat "${MAIN_DIR}"/*.TMP |sort -ru |
    grep -v -e \/\.Trash -e \/twi\/ -e \/twitemp\/ -e \/linux_iso\/ \
            -e \/gallery-dl\/ >"${MAIN_DIR}"/ALL.DATA
    (   cd "${MAIN_DIR}"
        /usr/bin/rm *.txt
        split -n "${CPU}" --numeric-suffixes=1 \
              --additional-suffix='.txt' ALL.DATA movlocate-data
        /usr/bin/rm *.TMP ALL.DATA
    )

    if [[ "$HOME/.config/updatedb/updatedb.time" ]] ;then
        sha512sum "$HOME/.config/updatedb/updatedb.time" >"${MAIN_DIR}"/updatedb.sha512
    fi
    #####| tlocate provisioning |#####
    echo "TEMP" >"${MAIN_DIR}"/tlocate
    doas chmod 755 "${MAIN_DIR}"/tlocate
    cat <<- '#___TLOCATE' >"${MAIN_DIR}"/tlocate
#!/usr/bin/env bash
#
# Written by: crossroads1112
# Purpose: mlocate written in bash, uses plain text file instead of database for indexing
#
#########################################################################################
#techo(){ # Echos message prepended with name of script, interpreting special characters and not printing a newline at the end
#    echo -ne "${0##*/}: $@"
#}
techoerr(){ # See above but prints to stderr
    >&2 echo -ne "${0##*/}: $@"
}
updateTxt(){ : ;}

queryTxt(){
    # Ensure that there are arguments
    (( $# == 0 )) && { techoerr "ERROR: no query for which to search\nRun ${0##*/} --help for more information\n"; return 1;}
    # This is admittedly a crude way to ensure that it is a valid text file. It greps for the regex of the "last updated" line

    # This is really pretty complex and since it is all really one line, I can't add comments telling what each thing does.
    # TL;DR: it generates the apropriate grep command based upon the arguments and options
    [[ $all == 1 ]] && \
        grepCmd=$(echo -n "grep $grepArgs -- '$(
            if (( findBasename == 1 && noRegex == 1 )); then\
                echo -n "$(printf '%q' "$1" | sed 's/\+/\\\+/g' | sed 's/\./\\\./g' | sed 's/\\</</' | sed 's/\\>/>/')[^/]*$";\
            elif (( findBasename == 1 && noRegex == 0 )); then\
                echo -n "$(sed 's/^\^/\//' <<<"$1")[^/]*$"; \
            else \
                echo -n "$1";\
            fi)' $txtFile "; \
        shift;\
        for term in "$@"; do\
            echo -n "| grep $grepArgs -- '$(
            if (( findBasename == 1 && noRegex == 1 )); then\
                echo -n "$(printf '%q' "$term" | sed 's/\+/\\\+/g' | sed 's/\./\\\./g' | sed 's/\\</</' | sed 's/\\>/>/')[^/]*$";\
            elif (( findBasename == 1 && noRegex == 0 )); then\
                echo -n "$(sed 's/^\^/\//' <<<"$term")[^/]*$"; \
            else \
                echo -n "$term";\
            fi)'";\
        done) || \
        \
        grepCmd="grep $grepArgs $(
            (( findBasename != 0  || noRegex != 1 )) && echo -n "-- '"; \
            for term in "$@"; do \
                if (( findBasename == 1 && noRegex == 1 )); then\
                   echo -n "$(printf '%q' "$term" | sed 's/\+/\\\+/g' | sed 's/\./\\\./g' | sed 's/\\</</' | sed 's/\\>/>/')[^/]*$|";\
                elif (( findBasename == 1 && noRegex == 0 )); then\
                   echo -n "$(sed 's/^\^/\//' <<<"$term")[^/]*$|";\
                elif (( findBasename == 0 && noRegex == 1 )); then\
                    echo -n "-e '$term' "; \
                elif (( findBasename == 0 && noRegex == 0 )); then\
                    echo -n "${term}|";\
                fi; done | \
                sed 's/|$//' | sed -r 's/ +$//')$( (( findBasename != 0 || noRegex != 1 )) && echo -n "'" ) $txtFile"
    # Whew, that was intense

    # This next block here adds the grep command that filters out lines that start with '#' (to avoid matching things generated by this script).
    # If some test/filter is specified it adds the while loop and if there is more than one, it adds {} around the filters for cleanliness
    wholeCmd="$grepCmd | grep -v '^#'$(
        if (( doTest == 1 )); then \
            echo -n " | while read path; do $(
                if (( customTestCount > 1 )); then\
                    echo -n "{ $(sed 's/ $//' <<<"$testCmd"); } ";\
                else \
                    echo -n "$testCmd";\
                fi)&& echo \"\$path\"; done";\
        fi)${headCmd}${nullCmd}${countCmd}"

    # This bit is pretty obvious. If showCmd equals 1, echo the command, otherwise execute it.
    # There is a bit of inefficiency here in that it evals the grep command twice which is wasteful.
    # The first time, it does so to ensure that there is output (otherwise it fails) and the next time in prints it.
    # This was necessary due to issues I had with capturing the exit code of the grep command
    (( showCmd == 1 )) &&\
        { echo "$wholeCmd"; return 0; }\
        || \
        { [[ -z $(eval "$wholeCmd") ]] && return 1 || eval "$wholeCmd"; }

    # Add that "Last updated" line to the end of the output
   #(( quiet == 0 )) &&\
   #    techo "List last updated $(head -n1 $txtFile | sed 's/#//')\n"  || true
}

txtStats(){ : ;}
customTest(){ : ;}
sanityChecks(){ : ;}
getChecksum(){ : ;}
validateTxtFile(){ : ;}

configFiles="/etc/${0##*/}.conf"
txtFile="/etc/${0##*/}.txt"
txtFileChecksumPath="/etc/.${0##*/}.checksum"
date="$(date "+#% Dat %l:%M %p" | tr -s ' ' ' ')"

noRegex=0
isEmpty=0
all=0
update=0
showCmd=0
findWholename=0
isValid=0
stats=0
customTestCount=0
noChecksum=0
doTest=0
checksumsMatch=0
validationFailed=0
shaAlgorithm='1'
findBasename=0
[[ -t 1 ]] && quiet=0 || quiet=1

grepArgs="-E"
countCmd=
nullCmd=
txtFileChecksum=
checkLogOp="&&"
testCmd=
TEMP="$(getopt -o b,h,0,n,i,w,o,t:,p,A,e,u,c,S,q,a,n,l: -l help,and,or,wholename,files,dirs,links,files-zero,files-nonzero,has-read,has-write,has-execute,char-devs,block-devs,sockets,pipes,user-owned,group-owned,has-setgid,has-setuid,has-sticky,no-files,no-dirs,no-links,no-has-read,no-has-write,no-has-execute,no-char-devs,no-block-devs,no-sockets,no-user-owned,no-group-owned,no-has-sticky,no-pipes,no-has-setgid,no-has-setuid,statistics,basename,pretend,null,quiet,noregex,count,ignore-casetxtfile:,existing,update,all,limit,nochecksum -n "${0##*/}" -- "$@")" || exit 2

helpMsg="Usage: ${0##*/} [OPTION]... [PATTERN]...\n\
Search for entries in the ${0##*/} text file\n\n\
OPTIONS:\n\
-A,--all\t\tonly print entries that match all patterns\n\
-b,--basename\t\tmatch only the base name of path names\n\
-c,--count\t\tonly print number of found entries\n\
-t,-txtfile\t\tTXTFILE use TXTFILE instead of default text file (which is $txtFile)\n\
-e,--existing\t\tonly print entries for currently existing files\n\
-h,--help\t\tprint this help\n\
-i,--ignore-case\tignore case distinctions when matching patterns\n\
-l,--limit\t\tLIMIT limit output (or counting) to LIMIT entries\n\
-n,--noregex\t\tinterpret PATTERN literally rather than as a regular expression\n\
-p,--pretend\t\tprint the query or update command that would be run instead of running it\n\
-0,--null\t\tseparate entries with NUL on output\n\
-S,--statistics\t\tprint statistics about the ${0##*/} text file ($txtFile by default)\n\
-q,--quiet\t\tsupress \"${0##*/}: \" messages and timestamp when querying (automatically enabled when feeding into a pipe)\n\
-u,--update\t\t update filelist.\n\
-v,--verbose\t\t update filelist with verbose stdout. Noisy, but easy to find trouble.\n\
-w, --wholename\t\tmatch whole path name (default). Overrides --basename\n\
--nochecksum\t\tdo not verify checksum of TXTFILE\n\
\
\
The following options allow for the filtering of the responses by type or attribute. These options also may cause slowdowns in querys with lots of results. All of the following filters imply --existing\n\n\
\
--files, --no-files\t\t\tentry is (not) regular file (includes links)\n\
--dirs, --no-dirs\t\t\tentry is (not) a directory\n\
--links, --no-links\t\t\tentry is (not) a symbolic link\n\
--char-devs, --no-char-devs\t\tentry is (not) a character device\n\
--block-devs, --no-block-devs\t\tentry is (not) a block device\n\
--sockets,--no-sockets\t\t\tentry is (not) a socket\n\
--pipes,--no-pipes\t\t\tentry is (not) a pipe\n\
--files-zero,--files-nonzero\t\tentry a file and is (not) zero bytes in length\n\
--has-read,--no-has-read\t\tread permission is (not) granted on entry\n\
--has-write,--no-has-write\t\twrite permission is (not) granted on entry\n\
--has-execute,--no-has-execute\t\texecute permission is (not) granted on entry\n\
--user-owned,--no-user-owned\t\tentry is owned effective user ID\n\
--group-owned,--no-group-owned\t\tentry is owned by effective group ID\n\
--has-setuid,--no-has-setuid\t\tset-user-ID bit is (not) set on entry\n\
--has-setgid,--no-has-setgid\t\tentry is (not) set-group-ID\n\
--has-sticky,--no-has-sticky\t\tsticky bit is (not) set on entry\n\
-o,--or\t\t\t\t\tAdd logical operator OR between two filters\n\
-a,--and\t\t\t\tAdd logical operator AND between two filters\n\n\
\
NOTE: To use multiple filters, you must specify --or or --and between each filter"

for i in "${configFiles[@]}"; do
    [[ -f "$i" ]] && source "$i"
done

(( $# == 0 )) && { techoerr "ERROR: no query for which to search\nRun ${0##*/} --help for more information\n"; exit 1;}

eval set -- "$TEMP"
while true; do
    case "${1}" in
        -u|--update) update=1;;
        -q|--quiet) quiet=1;;
        -h|--help) echo -e "$helpMsg" ;; #| less; exit;;
        -l|--limit)
            if [[ "$2" =~ ^[0-9]+$ ]]; then
                headCmd=" | head -n${2}"
                shift
            else
                techoerr "Limit must be a positive integer\n"
                exit 1
           fi
           ;;
       -c|--count)countCmd=" | wc -l";;
       -A|--all) all=1;;
       -e|--existing)  customTest '-e';;
       -t|--txtfile)txtFile="$2";;
       -i|--ignore-case) grepArgs+=" -i";;
       -p|--pretend)showCmd=1; quiet=1;;
       -n|--noregex) noRegex=1;;
       -S|--statistics) stats=1;;
       -0|--null)quiet=1;nullCmd=" | tr '\n' '\x00'" ;;
       -b|--basename) findBasename=1;;
       -w|--wholename)findWholename=1;;
       -o|--or) testCmd+="|| ";;
       -a|--and) testCmd+="&& ";;
       --nochecksum) noChecksum=1 ;;
       --files)customTest '-f';;
       --no-files) customTest '! -f';;
       --dirs)customTest '-d';;
       --no-dirs)customTest '-d';;
       --links)customTest '-h';;
       --no-links)customTest '! -h';;
       --files-nonzero)customTest '-s';;
       --files-zero)customTest '! -s';;
       --has-read)customTest '-r';;
       --no-has-read) customTest '! -r';;
       --has-write) customTest '-w';;
       --no-has-write) customTest '! -w';;
       --has-execute) customTest '-x';;
       --no-has-execute) customTest '! -x';;
       --char-devs) customTest '-c';;
       --no-char-devs) customTest '! -c';;
       --block-devs) customTest '-b';;
       --no-block-devs) customTest '! -b';;
       --sockets) customTest '-S';;
       --no-sockets) customTest '! -S';;
       --user-owned) customTest '-O';;
       --no-user-owned) customTest '! -O';;
       --group-owned) customTest '-G';;
       --no-group-owned) customTest '! -G';;
       --has-sticky) customTest '-k';;
       --no-has-sticky) customTest '! -k';;
       --pipes) customTest '-p';;
       --no-pipes) customTest '! -p' ;;
       --has-setgid) customTest '-g' ;;
       --no-has-setgid) customTest '! -g';;
       --has-setuid) customTest '-u';;
       --no-has-setuid) customTest '! -u';;
       --) shift; break;;
   esac
   shift
done

#sanityChecks
#if [[ -f "$txtFile" ]]; then
#    getChecksum
#    validateTxtFile || exit
#fi

if (( update == 1 )); then
    echo "Update, disabled."
#    updateTxt
    exitCode=$?
    (( stats == 1 )) && getChecksum
elif (( stats == 1 )) && (( $# == 0 )); then
#    txtStats
    echo "Stats, disabled."
    exit 0
else
    (( stats == 1 )) && quiet=1
    queryTxt "$@"
    exitCode=$?
fi
(( stats == 1 )) && { printf -- "-%.0s" $(seq 1 $(tput cols)) ;echo; txtStats; }
exit $exitCode

#___TLOCATE

    #####| sync "folder on tmpfs" <=> "${STOCK_DIR}" |#####
    rsync -Paz "${MAIN_DIR}/" "${STOCK_DIR}" &>/dev/null
   #rsync -Pahvz "/tmp/movlocate/" "$HOME/.cache/movlocate"
    echo "$(cat *.txt |wc -l) files found."
    return 0
}


